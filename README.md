# SLR-parser

## типо дневник

с помощью скрипта grammar_gen.rb из описания грамматики в grammar.txt генерируются в /grammar/generated:
- enum Symbol в symbol_enums.hpp
- вектор грамматических правил в grammar_rules.cpp

токены: по описанию в grammar/tokens_def.rb генерируются enum-ы токенов в C++.

Приходится в ручную поддерживать когерентность описаний Symbol, Token, и описанием лексики в lexer.l.

## TODO:

- генерацию грамматики проверить, и где вообще когерентность нужно поддерживать
- тесты добавить на парсер, на построение таблиц тест можно в целом тоже
- описание проекта бы более подробно сделать, с мини описанием мотивации решений архитектурных, языковых и т.д.

## LR(k) грамматика

LR(k) (Left-toRight scanning, Rightmost derivation in reverse, k-lookahead) - класс контекстно-свободных грамматик, для которых возможно построение детерминированного восходящего синтаксического анализатора.

Восходящий синтаксический анализатор принимает решения на основе состояния следующих элементов:

1. Input (уже прочитанный вход, не более чем на k символов вперед)
2. Stack (содержание стэка)

В данном проекте используется подмножество LR(1) - SLR(1) для учебных целей ввиду простоты реализации по сравнению с LR(1).

## SLR-parser

В данном методе разбора входная строка из терминалов постепенно "сворачивается" (операция "reduce") по подстрокам к нетерминалам, пока не получится начальный символ грамматики.


### DFA

Для распознавания правых порождений в обратном порядке можно использовать конечный автомат, где
- Состояния DFA: множества пунктов (items) с замыканием
- Переходы: GOTO(I, X), где X - символ грамматики

Конечный автомат здесь моделирует все промежуточные точки в процессе распознавания правил грамматики.


#### Items

Пункт(Item) - правило грамматики с точкой ( . ), показывающей, до какого места уже распознано грамматическое правило.

Т.е. эта конструкция введена как эквивалент текущего положения при парсинге.

Пример:

Для правила:
```cpp
E -> E + T
```
Возможные пункты:
```cpp
E -> . E + T    // ничего не распознано
E -> E . + T    // распознано E
E -> E + . T    // распознано E +
E -> E + T .    // все распознано и готово к свертке
```

С помощью пунктов можно описывать состояния парсера, отсюда возникает модель конечного автомата (DFA - Deterministic Finite Automaton).

Множество всех состояний - это замыкание(closure) множества всех пунктов

#### Closure

Замыкание(closure) - операция над множеством пунктов, которая для пунктов вида

```cpp
A -> a . B b
```

Добавляет все пункты вида

```cpp
B -> . y
```

Прмиер:

Исходный пункт:

```cpp
E -> . T
```

При наличии правил

```cpp
T -> T * P
T -> P
```

 closure добавит:

```cpp
T -> . T * P
T -> . P
P -> . ...
```

Через замыкание добавляются все возможные сценарии последующих символов.

#### GOTO

GOTO - функция перехода LR(0) автомата по нетерминалам.

GOTO(I, X) - это состояние автомата, в которое мы переходим из состояния I по символу X, где X - нетерминал.

Пример:
```cpp
I = {               // текущее состояние
    E -> T .,
    T -> T . * P
}

GOTO(I, *) = { T -> T * . P } // состояние после перехода по '*'

```

т.е. это как бы сдвиг на выбранный символ.


### Операции конечного автомата (Actions)
| Action | Описание |
|--------|------|
| Shift  | перемещение следующего символа строки на вершину стэка |
| Reduce | если вершина стэка совпадает с сентенциальной формой, заменяем порожденную форму на начальную. Т.е. если на вершине стэка **a**, совпадающее с правой частью правила **A -> a**, заменяем **a** на **A** на вершине стэка |
| Accept | строку удалось сматчить до начального символа грамматики |
| Error  | ошибка, нет подходящего грамматического правила |


----------------- здесь про модель конечного автомата добавить



---- добавить

### Reduce




### SLR-table

SLR-таблица строится на основе свех состояний LR(0)-автомата, где каждое состояние - это замыкание(closure) множества пунктов


Таблица ACTION[state, terminal] определяет, что делать, когда на вершине стека состояние state, а следующий входной символ — terminal.
Возможные действия: shift, reduce, accept, error.

Таблица GOTO[state, nonterminal] определяет, в какое состояние перейти после того, как выполнен reduce.
Это просто переход в новое состояние DFA (LR(0)-автомата) по символу-нетерминалу.

### Внутренности SLR парсера

SLR парсер использует два стэка: стэк состояний и стэк символов

### Инициализация

State stack: содержит одно состояние - начальное

### Конечное состояние(успех):

1) на входе - EOF('$')
2) на вершине стэка состояний - состояние start
3) в таблице ACTION[start]['$'] = accept
